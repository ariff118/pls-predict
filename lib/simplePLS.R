#' seminr simplePLS Function
#'
#' The \code{seminr} package provides a natural syntax for researchers to describe PLS
#' structural equation models. \code{seminr} is compatible with simplePLS.
#' \code{simplePLS} provides the verb for estimating a pls model.
#'
#' @param obsData A \code{dataframe} containing the indicator measurement data.
#'
#' @param smMatrix A source-to-target matrix representing the inner/structural model,
#'   generated by \code{relationships}.
#'
#' @param mmMatrix A source-to-target matrix representing the outer/measurement model,
#'   generated by \code{constructs}.
#'
#' @param maxIt The maximum number of iterations to run (default is 300).
#'
#' @param stopCriterion The criterion to stop iterating (default is 7).
#'
#' @usage
#' simplePLS(obsData,smMatrix, mmMatrix, maxIt=300, stopCriterion=7)
#'
#' @seealso \code{\link{relationships}} \code{\link{constructs}} \code{\link{paths}} \code{\link{interactions}}
#'          \code{\link{estimate_pls}} \code{\link{bootstrap_model}}
#'
#' @examples
#' mobi <- mobi
#'
#' #seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'              reflective("Image",        multi_items("IMAG", 1:5)),
#'              reflective("Expectation",  multi_items("CUEX", 1:3)),
#'              reflective("Quality",      multi_items("PERQ", 1:7)),
#'              reflective("Value",        multi_items("PERV", 1:2)),
#'              reflective("Satisfaction", multi_items("CUSA", 1:3)),
#'              reflective("Complaints",   single_item("CUSCO")),
#'              reflective("Loyalty",      multi_items("CUSL", 1:3))
#'            )
#' #seminr syntax for creating structural model
#' mobi_sm <- relationships(
#'   paths(from = "Image",        to = c("Expectation", "Satisfaction", "Loyalty")),
#'   paths(from = "Expectation",  to = c("Quality", "Value", "Satisfaction")),
#'   paths(from = "Quality",      to = c("Value", "Satisfaction")),
#'   paths(from = "Value",        to = c("Satisfaction")),
#'   paths(from = "Satisfaction", to = c("Complaints", "Loyalty")),
#'   paths(from = "Complaints",   to = "Loyalty")
#' )
#'
#' mobi_pls <- estimate_pls(data = mobi,
#'                            measurement_model = mobi_mm,
#'                            structural_model = mobi_sm)
#'
#' # Estimate model with bootstrapped significance
#' mobi_pls <- bootstrap_model(data = mobi,
#'                            measurement_model = mobi_mm,
#'                            structural_model = mobi_sm,
#'                            nboot = 500)
#'
#' print_paths(mobi_pls)
#' plot_scores(mobi_pls)
#'
#' @export
simplePLS <- function(obsData,smMatrix, mmMatrix, maxIt=300, stopCriterion=7){

  #Create list of Measurements Variables
  mmVariables <- mmMatrix[,"measurement"]

  #Create list of Latent Variables
  ltVariables <- unique(c(smMatrix[,1],smMatrix[,2]))

  #Extract and Normalize the measurements for the model
  normData <- scale(obsData[,mmVariables],TRUE,TRUE)

  #Extract Mean and Standard Deviation of measurements for future prediction
  meanData <- attr(normData, "scaled:center")
  sdData <- attr(normData, "scaled:scale")

  #Create a matrix of outer_weights
  outer_weights <- matrix(data=0,
                          nrow=length(mmVariables),
                          ncol=length(ltVariables),
                          dimnames = list(mmVariables,ltVariables))

  #Initialize outer_weights matrix with value 1 for each relationship in the measurement model
  for (i in 1:length(ltVariables))  {
    outer_weights [mmMatrix[mmMatrix[,"latent"]==ltVariables[i],
                            "measurement"],
                   ltVariables[i]] =1
  }

  #Create a matrix of inner paths
  #? inner_paths => inner_weights?
  inner_paths <- matrix(data=0,
                        nrow=length(ltVariables),
                        ncol=length(ltVariables),
                        dimnames = list(ltVariables,ltVariables))

  #Iterative Process Starts here
  for (iterations in 0:maxIt)  {

    #Estimate Factor Scores from Outter Path
    #? fscores <- normData%*%outer_weights
    fscores <- normData[,mmVariables]%*%outer_weights

    #Standardize Factor Scores
    fscores <- scale(fscores,TRUE,TRUE)

    #Estimate inner paths (symmetric matrix)
    for (i in 1:nrow(smMatrix))  {
      inner_paths[smMatrix[i,"source"],
                  smMatrix[i,"target"]] = cov(fscores[,smMatrix[i,"source"]],
                                              fscores[,smMatrix[i,"target"]])
      #? next step necessary?
      inner_paths[smMatrix[i,"target"],
                  smMatrix[i,"source"]] = cov(fscores[,smMatrix[i,"source"]],
                                              fscores[,smMatrix[i,"target"]])
    }

    #Estimate Factor Scores from Inner Path
    fscores<-fscores%*%inner_paths

    #Standarize Factor Scores
    fscores <- scale(fscores,TRUE,TRUE)

    #Save last outer_weights
    last_outer_weights <- outer_weights

    #Update outer_weights
    for (i in 1:length(ltVariables))  {

      #If the measurement model is Mode B Composite
      if(measure_mode(ltVariables[i],mmMatrix)=="B"){
        outer_weights[mmMatrix[mmMatrix[,"latent"]==ltVariables[i], "measurement"], ltVariables[i]] =
          solve(cor(normData[,mmMatrix[mmMatrix[,"latent"]==ltVariables[i],"measurement"]])) %*%
                  cor(normData[,mmMatrix[mmMatrix[,"latent"]==ltVariables[i],"measurement"]],
                fscores[,ltVariables[i]])
      }

      #If the measurement model is Mode A Composite or Mode A Consistent
      if(measure_mode(ltVariables[i],mmMatrix)=="C" | measure_mode(ltVariables[i],mmMatrix)=="A"){
        outer_weights[mmMatrix[mmMatrix[,"latent"]==ltVariables[i], "measurement"], ltVariables[i]] =
          cov(normData[,mmMatrix[mmMatrix[,"latent"]==ltVariables[i],"measurement"]],fscores[,ltVariables[i]])
      }
    }

    #Estimate Factor Scores from Outer Weights
    fscores <- normData[,mmVariables]%*%outer_weights

    #Standarize outer_weights
    for (i in 1:length(ltVariables))  {
      outer_weights [mmMatrix[mmMatrix[,"latent"]==ltVariables[i], "measurement"], ltVariables[i]] =
        outer_weights [mmMatrix[mmMatrix[,"latent"]==ltVariables[i], "measurement"], ltVariables[i]] / sd(fscores[,ltVariables[i]])
    }

    #Verify the stop criteria
    weightDiff <- sum(abs(outer_weights-last_outer_weights))
    if (weightDiff <(10^(-(stopCriterion))))
      break

  } #Finish Iterative Process

  #Estimate Factor Scores from Outter Path
  fscores <- normData[,mmVariables]%*%outer_weights

  #Create a matrix of Outer Loadings
  outer_loadings <- matrix(data=0,
                           nrow=length(mmVariables),
                           ncol=length(ltVariables),
                           dimnames = list(mmVariables,ltVariables))


  #Calculate the Outer Loadings
  for (i in 1:length(ltVariables))  {
    outer_loadings [mmMatrix[mmMatrix[,"latent"]==ltVariables[i],
                             "measurement"],
                    ltVariables[i]] = cov(normData[,mmMatrix[mmMatrix[,"latent"]==ltVariables[i],"measurement"]],fscores[,ltVariables[i]])

  }

  # interaction adjustment
  for(latent in ltVariables) {
    adjustment <- 0
    denom <- 0
    if(grepl("\\.", latent)) {
      list <- mmMatrix[mmMatrix[,"latent"]==latent,"measurement"]

      for (item in list){
        adjustment <- adjustment + sd(obsData[,item])*abs(as.numeric(outer_loadings[item,latent]))
         denom <- denom + abs(outer_loadings[item,latent])
      }
      adjustment <- adjustment/denom
      fscores[,latent] <- fscores[,latent]*adjustment
    }
  }

  #Create a matrix of Outer Loadings
  outer_loadings <- matrix(data=0,
                           nrow=length(mmVariables),
                           ncol=length(ltVariables),
                           dimnames = list(mmVariables,ltVariables))


  #Calculate the Outer Loadings
  for (i in 1:length(ltVariables))  {
    outer_loadings [mmMatrix[mmMatrix[,"latent"]==ltVariables[i],
                             "measurement"],
                    ltVariables[i]] = cov(normData[,mmMatrix[mmMatrix[,"latent"]==ltVariables[i],"measurement"]],fscores[,ltVariables[i]])

  }

  #Identify which variables have incoming paths
  dependant<-unique(smMatrix[,"target"])

  #Initialize Matrix of Path Coefficients and matrix of r-squared
  path_coef <- matrix(data=0,
                      nrow=length(ltVariables),
                      ncol=length(ltVariables),
                      dimnames = list(ltVariables,ltVariables))
  rSquared <- matrix(,nrow=2,ncol=length(dependant),byrow =TRUE,dimnames = list(c("Rsq","AdjRsq"),dependant))

  #We calculate a linear regresion for each dependant variable
  for (i in 1:length(dependant))  {

    #Indentify the independant variables
    independant<-smMatrix[smMatrix[,"target"]==dependant[i],"source"]

    #Solve the system of equations
    results = solve(t(fscores[,independant]) %*% fscores[,independant]) %*% (t(fscores[,independant]) %*% fscores[,dependant[i]])

    #Transform to a generic vector
    coefficients <- transform_to_named_vector(results,independant)

    #Assign the Beta Values to the Path Coefficient Matrix
    for (j in 1:length(independant))
      path_coef[independant[j],dependant[i]]=coefficients[independant[j]]

    # Calculate r-squared for the endogenous variable
    fscore_cors <- cor(fscores)
    r_sq <- 1 - 1/solve(fscore_cors[c(independant,dependant[i]),c(independant,dependant[i])])
    rSquared[1,i] <- r_sq[dependant[i],dependant[i]]
    rSquared[2,i] <- 1 - (1 - rSquared[1,i])*((nrow(obsData)-1)/(nrow(obsData)-length(independant) - 1))
  }

  #Prepare return Object
  plsModel <- list(meanData = meanData,
                   sdData = sdData,
                   smMatrix = smMatrix,
                   mmMatrix = mmMatrix,
                   ltVariables = ltVariables,
                   mmVariables = mmVariables,
                   outer_loadings = outer_loadings,
                   outer_weights = outer_weights,
                   path_coef = path_coef,
                   iterations = iterations,
                   weightDiff = weightDiff,
                   fscores = fscores,
                   rSquared = rSquared)

  class(plsModel) <- "plsModel"
  return(plsModel)
}

